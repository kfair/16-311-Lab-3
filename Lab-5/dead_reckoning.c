#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
 * Lab 3 : Starter code
 * Written by Kaushik Viswanathan,
 * Modified by Allan Wang (Jan 2017)

 * Feel free to modify any part of these codes.
 **********************************************/

//Global variables - you will need to change some of these
//Robot's positions
float robot_X = 0.0, robot_Y = 0.0, robot_TH = 0.0;

int velocityUpdateInterval = 5;
int PIDUpdateInterval = 2;

/*****************************************
 * Complete this function so that it
 * continuously updates the robot's position
 *****************************************/
task dead_reckoning()
{

	while(1)
	{
		//
		// Fill in code for numerical integration / position estimation here
		//

		/*Code that plots the robot's current position and also prints it out as text*/
		nxtSetPixel(50 + (int)(100.0 * robot_X), 32 + (int)(100.0 * robot_Y));
		nxtDisplayTextLine(0, "X: %f", robot_X);
		nxtDisplayTextLine(1, "Y: %f", robot_Y);
		nxtDisplayTextLine(2, "t: %f", robot_TH);

		wait1Msec(velocityUpdateInterval);
	}
}

/*****************************************
 * Function that draws a grid on the LCD
 * for easier readout of whatever is plot
 *****************************************/
void draw_grid()
{
	for(int i = 0; i < 65; i++)
	{
		nxtSetPixel(50, i);
		int grid5 = (i - 32) % 5;
		int grid10 = (i - 32) % 10;
		if(!grid5 && grid10)
		{
			for(int j = -2; j < 3; j++)
			{
				nxtSetPixel(50 + j, i);
			}
		}
		else if(!grid10)
		{
			for(int j = -4; j < 5; j++)
			{
				nxtSetPixel(50 + j, i);
			}
		}
	}
	for(int i = 0; i < 101; i++)
	{
		nxtSetPixel(i, 32);
		int grid5 = (i - 100) % 5;
		int grid10 = (i - 100) % 10;
		if(!grid5 && grid10)
		{
			for(int j = -2; j < 3; j++)
			{
				nxtSetPixel(i, 32 + j);
			}
		}
		else if(!grid10)
		{
			for(int j = -4; j < 5; j++)
			{
				nxtSetPixel(i, 32 + j);
			}
		}
	}
}

/**********************************************
 * Function that judges if two floats are equal
 **********************************************/
 bool equal(float a, float b) {
   float epsilon = 1;
   if (abs(a-b) < epsilon) {
     return true;
   } else {
     return false;
   }
 }

float distToDegrees(float dist) {
	return dist * 0.1470 * 360.0;
}

float capMotor(float m) {
	int cap = 80;
	if (m > cap) {
		return cap;
	}
	else if (m < -cap) {
		return cap;
	}
	else {
		return m;
	}
}
// Takes distance in inches.
void driveStraight(float dist) {

	float p = 0.5;
	float turnP = 0.5;
	// Convert the distance from inches to degrees in the wheel.
	float target = distToDegrees(dist);
	// Reset the encoders.
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	writeDebugStreamLine("Driving straight %d inches", dist);
	float avgEnc = 0;
	while(abs(target - avgEnc) > 1) {
		avgEnc = (nMotorEncoder[leftMotor] + nMotorEncoder[rightMotor]) / 2.0;

		float left = p * (target- nMotorEncoder[leftMotor]);
		float right = p * (target - nMotorEncoder[rightMotor]);
		// Cap the values so that turn correction has a bigger effect.
		left = capMotor(left);
		right = capMotor(right);
		// Add in corrections for driving straight
		left -= turnP * (nMotorEncoder[leftMotor] - nMotorEncoder[rightMotor]);
		right += turnP * (nMotorEncoder[leftMotor] - nMotorEncoder[rightMotor]);

		motor[leftMotor] = left;
		motor[rightMotor] = right;
	}
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void turnRight(float angle) {
	float turnSpeed = 50;
	float opposite = 1;

	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;

	if (angle < 0) opposite = -1;
	// Convert the turn length from degrees to rotations.
	float  turnLen = angle * 250.0 / 90.0;
	writeDebugStreamLine("Turning right %d degrees", angle);
	// We'll only look at the left encoder for the turn.
	while(abs(nMotorEncoder[leftMotor] - turnLen) > 1){
		motor[leftMotor] = opposite * turnSpeed;
		motor[rightMotor] = opposite * -turnSpeed;
	}
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}
/*****************************************
 * Main function - Needs changing
 *****************************************/
task main()
{
	/* Reset encoders and turn on PID control */
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	nMotorPIDSpeedCtrl[leftMotor] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[rightMotor] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

	draw_grid();
	startTask(dead_reckoning);
	turnRight(-90);
	wait1Msec(500);
	driveStraight(12);
	wait1Msec(500);
	turnRight(90);
	wait1Msec(500);
	driveStraight(12);

}
