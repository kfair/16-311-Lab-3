#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
 * Lab 3 : Starter code
 * Written by Kaushik Viswanathan,
 * Modified by Allan Wang (Jan 2017)
 * Feel free to modify any part of these codes.
 **********************************************/

//Global variables - you will need to change some of these
//Robot's positions
int PIDUpdateInterval = 2;

float distToDegrees(float dist) {
	//return dist * 0.1470 * 360.0;
	float mpi = 3.14159;
	float r = 1.08;							// Decrease to go further
	float rads = dist / r;
	return rads / mpi * 180;
}

float capMotor(float m) {
	int cap = 45;
	int min = 10;
	if (m > cap) {
		return cap;
	}
	else if (m < -cap) {
		return -cap;
	}
	else if(m < min && m > 0) {
		return min;
	}
	else if(m > -min && m <= 0) {
		return -min;
	}
	else {
		return m;
	}
}
// Takes distance in inches.
void driveStraight(float dist) {

	float p = 1;
	float turnP = 10;
	// Convert the distance from inches to degrees in the wheel.
	float target = distToDegrees(dist);
	// Reset the encoders.
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	writeDebugStreamLine("Driving straight %d inches", dist);

	float avgEnc = 0;
	while(abs(target - avgEnc) > 1) {
		avgEnc = (nMotorEncoder[leftMotor] + nMotorEncoder[rightMotor]) / 2.0;

		float left = p * (target - nMotorEncoder[leftMotor]);
		float right = p * (target - nMotorEncoder[rightMotor]);
		// Cap the values so that turn correction has a bigger effect.
		left = capMotor(left);
		right = capMotor(right);
		// Add in corrections for driving straight
		left -= turnP * (nMotorEncoder[leftMotor] - nMotorEncoder[rightMotor]);
		right += turnP * (nMotorEncoder[leftMotor] - nMotorEncoder[rightMotor]);

		motor[leftMotor] = left;
		motor[rightMotor] = right;
	}
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void turnRight(float angle) {
	float turnSpeed = 5;
	float opposite = 1;

	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;

	if (angle < 0) opposite = -1;
	// Convert the turn length from degrees to rotations.
	float  turnLen = angle * 195 / 90;
	writeDebugStreamLine("Turning right %d degrees", angle);

	while(opposite * -(nMotorEncoder[leftMotor] - turnLen) > 1 || opposite * (nMotorEncoder[rightMotor] + turnLen) > 1){
		//avgEnc = (nMotorEncoder[leftMotor] - nMotorEncoder[rightMotor]) / 2;
		int left = opposite * turnSpeed;
		int right = opposite * (-1*turnSpeed);
		if (opposite * -(nMotorEncoder[leftMotor] - turnLen) > 1) {
			motor[leftMotor] = left;
		}
		else if (opposite * -(nMotorEncoder[leftMotor] - turnLen) < -1) {
			motor[leftMotor] = -left;
		}
		else {
			motor[leftMotor] = 0;
		}
		if (opposite * (nMotorEncoder[rightMotor] + turnLen) > 1) {
			motor[rightMotor] = right;
		}
		else if (opposite * (nMotorEncoder[rightMotor] + turnLen) < -1) {
			motor[rightMotor] = right;
		}
		else {
			motor[rightMotor] = 0;
		}
	}
	writeDebugStreamLine("Turn error %d, %d, %d", nMotorEncoder[leftMotor], nMotorEncoder[rightMotor], turnLen);
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}
/*****************************************
 * Main function - Needs changing
 *****************************************/
task main()
{
	/* Reset encoders and turn on PID control */
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	nMotorPIDSpeedCtrl[leftMotor] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[rightMotor] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;
	//turnRight(-45.0);
	//while(nNxtButtonPressed != 3) {}
	turnRight(-63.43494882292201);
wait1Msec(100);
driveStraight(-17.88854381999832);
wait1Msec(100);
turnRight(63.43494882292201);
wait1Msec(100);
driveStraight(-10.0);
wait1Msec(100);
turnRight(-90.0);
wait1Msec(100);
driveStraight(16.0);
}
