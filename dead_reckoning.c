#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
 * Lab 3 : Starter code
 * Written by Kaushik Viswanathan,
 * Modified by Allan Wang (Jan 2017)
 * Feel free to modify any part of these codes.
 **********************************************/

//Global variables - you will need to change some of these
//Robot's positions
int PIDUpdateInterval = 2;

float distToDegrees(float dist) {
	//return dist * 0.1470 * 360.0;
	float mpi = 3.14159;
	float r = 1.07;							// Decrease to go further
	float rads = dist / r;
	return rads / mpi * 180;
}

float capMotor(float m) {
	int cap = 30;
	if (m > cap) {
		return cap;
	}
	else if (m < -cap) {
		return -cap;
	}
	else {
		return m;
	}
}
// Takes distance in inches.
void driveStraight(float dist) {

	float p = 1;
	float turnP = 0.5;
	// Convert the distance from inches to degrees in the wheel.
	float target = distToDegrees(dist);
	// Reset the encoders.
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	writeDebugStreamLine("Driving straight %d inches", dist);

	float avgEnc = 0;
	while(abs(target - avgEnc) > 1) {
		avgEnc = (nMotorEncoder[leftMotor] + nMotorEncoder[rightMotor]) / 2.0;

		float left = p * (target - nMotorEncoder[leftMotor]);
		float right = p * (target - nMotorEncoder[rightMotor]);
		// Cap the values so that turn correction has a bigger effect.
		left = capMotor(left);
		right = capMotor(right);
		// Add in corrections for driving straight
		left -= turnP * (nMotorEncoder[leftMotor] - nMotorEncoder[rightMotor]);
		right += turnP * (nMotorEncoder[leftMotor] - nMotorEncoder[rightMotor]);

		motor[leftMotor] = left;
		motor[rightMotor] = right;
	}
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void turnRight(float angle) {
	float turnSpeed = 5;
	float opposite = 1;

	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;

	if (angle < 0) opposite = -1;
	// Convert the turn length from degrees to rotations.
	float  turnLen = angle * 200 / 90;
	writeDebugStreamLine("Turning right %d degrees", angle);

	while(opposite * -(nMotorEncoder[leftMotor] - turnLen) > 1 || opposite * (nMotorEncoder[rightMotor] + turnLen) > 1){
		//avgEnc = (nMotorEncoder[leftMotor] - nMotorEncoder[rightMotor]) / 2;
		int left = opposite * turnSpeed;
		int right = opposite * (-1*turnSpeed);
		if (opposite * -(nMotorEncoder[leftMotor] - turnLen) > 1) {
			motor[leftMotor] = left;
		}
		else if (opposite * -(nMotorEncoder[leftMotor] - turnLen) < -1) {
			motor[leftMotor] = -left;
		}
		else {
			motor[leftMotor] = 0;
		}
		if (opposite * (nMotorEncoder[rightMotor] + turnLen) > 1) {
			motor[rightMotor] = right;
		}
		else if (opposite * (nMotorEncoder[rightMotor] + turnLen) < -1) {
			motor[rightMotor] = right;
		}
		else {
			motor[rightMotor] = 0;
		}
	}
	writeDebugStreamLine("Turn error %d, %d, %d", nMotorEncoder[leftMotor], nMotorEncoder[rightMotor], turnLen);
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}
/*****************************************
 * Main function - Needs changing
 *****************************************/
task main()
{
	/* Reset encoders and turn on PID control */
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	nMotorPIDSpeedCtrl[leftMotor] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[rightMotor] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;
	turnRight(-18.43494882292202);
	wait1Msec(500);
	driveStraight(12.649110640673518);
	wait1Msec(500);
	turnRight(-38.38653951768523);
	wait1Msec(500);
	driveStraight(-31.064449134018133);
	wait1Msec(500);
	turnRight(-33.17851165939276);
	wait1Msec(500);
	driveStraight(-28.0);
	wait1Msec(500);
	turnRight(-40.15599962491933);
	wait1Msec(500);
	driveStraight(-20.93442141545832);
	wait1Msec(500);
	turnRight(-85.06159334327336);
	wait1Msec(500);
	driveStraight(10.404326023342406);
}
