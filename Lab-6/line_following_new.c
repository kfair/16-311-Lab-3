#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S2,     ultrasonic,     sensorSONAR)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Line following values
int black = 35;
int white = 55;
int waitTime = 1;
int speed = 35;
float curve = 6.5;

// Dead recknoning values
float tickAngle = 360 / 16.0;

// Sonar values
int distance = 30;
int sonar = SensorValue(ultrasonic);
int prevSonar[4];
int prevAvg = SensorValue(ultrasonic);

// Localization values
int map[16];
float whereWeAre[16];

// Line following functions
task straight()
{
		motor[leftMotor] = speed + curve;
		motor[rightMotor] = speed - curve;
}
task left()
{
		motor[leftMotor] = speed - curve;
		motor[rightMotor] = speed + curve;
}
task right()
{
		motor[leftMotor] = speed + 2*curve;
		motor[rightMotor] = speed - 2*curve;
}

//Dead Reckoning
float position2(int rightDegrees) {
	return rightDegrees / 800.0 * 90.0;
}

void updateProbabilities(int ticks) {
	for (int i = 0; i < 16; i++) {
		whereWeAre[i] = whereWeAre[i] * (map[i] + .5);
	}
}

bool seenLastOne(int ticks, int wallsSeen){
	int sum = 0;
	for (int i = 0; i < 16; i++){
		sum += map[i];
	}
	return(sum == wallsSeen);
}

task main()
{
	map[0] = 0; map[1] = 0; map[2] = 1; map[3] = 1;
	map[4] = 0; map[5] = 1; map[6] = 0; map[7] = 1;
	map[8] = 1; map[9] = 0; map[10] = 0; map[11] = 0;
	map[12] = 0; map[13] = 0; map[14] = 0; map[15] = 1;

	float angle = 0;
	float ticks = 0;
	bool foundFirstWall = false;

	int wallsSeen = 0;

	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	while (!seenLastOne(ticks, wallsSeen))
	{
		//Line following
		int light = SensorValue(lightSensor);
		if (light < black)
		{
			startTask(left);
		}
		else if (light > white)
		{
			startTask(right);
		}
		else
		{
			startTask(straight);
		}

		sonar = SensorValue(ultrasonic);

		angle = position2(nMotorEncoder[rightMotor]);

		int prevTicks = round(ticks);
		ticks = ((angle / tickAngle));

		if ((sonar < distance) && (prevAvg >= distance)) {

			prevSonar[1] = sonar;
			prevSonar[2] = sonar;
			prevSonar[3] = sonar;
			wallsSeen += 1;

			playTone(500, 25); while(bSoundActive);
			if (!foundFirstWall) {
				//Only start counting ticks from our first wall.
				nMotorEncoder[leftMotor] = 0;
				nMotorEncoder[rightMotor] = 0;
				for(int i = 0; i <16; i++){
					whereWeAre[i] = map[i];
				}
				ticks = 0;
			}
			else{
				updateProbabilities(round(ticks));
			}
			foundFirstWall = true;
			writeDebugStreamLine("Ticks %f", ticks);
			writeDebugStreamLine("%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", whereWeAre[0], whereWeAre[1], whereWeAre[2], whereWeAre[3], whereWeAre[4], whereWeAre[5], whereWeAre[6], whereWeAre[7], whereWeAre[8], whereWeAre[9], whereWeAre[10], whereWeAre[11], whereWeAre[12], whereWeAre[13], whereWeAre[14], whereWeAre[15]);
		}
		prevSonar = sonar;
		if (foundFirstWall && prevTicks != round(ticks)) {
			float save = whereWeAre[15];
			for(int i = 15; i >= 1; i--){
				whereWeAre[i] = whereWeAre[i-1];
			}
			whereWeAre[0] = save;

			//writeDebugStreamLine("Shifting!!!");
			//writeDebugStreamLine("Ticks: %d", round(ticks));
			//writeDebugStreamLine("%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", whereWeAre[0], whereWeAre[1], whereWeAre[2], whereWeAre[3], whereWeAre[4], whereWeAre[5], whereWeAre[6], whereWeAre[7], whereWeAre[8], whereWeAre[9], whereWeAre[10], whereWeAre[11], whereWeAre[12], whereWeAre[13], whereWeAre[14], whereWeAre[15]);
		}

		int sum = 0;
		//update previous sonar values
		for (int i = 0; i < 3; i++){
			prevSonar[i] = prevSonar[i+1];
			sum = sum + prevSonar[i];
		}
		sum = sum + sonar;
		sum = sum - prevSonar[0];
		prevSonar[3] = sonar;

		prevAvg = sum/3;

		wait1Msec(waitTime);
	}
	writeDebugStreamLine("%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", whereWeAre[0], whereWeAre[1], whereWeAre[2], whereWeAre[3], whereWeAre[4], whereWeAre[5], whereWeAre[6], whereWeAre[7], whereWeAre[8], whereWeAre[9], whereWeAre[10], whereWeAre[11], whereWeAre[12], whereWeAre[13], whereWeAre[14], whereWeAre[15]);
}
