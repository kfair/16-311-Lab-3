#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S2,     ultrasonic,     sensorSONAR)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Line following values
int black = 35;
int white = 55;
int waitTime = 1;
int speed = 35;
float curve = 6.5;

// Dead recknoning values
float axleLen = 4.875;
float wheelDist = axleLen / 2;
float wheelR = 1.032;			// Decrease to go farther
float r = 12;
float tickAngle = 360 / 16;
float ticks = 0;
float fudgeFactor = 0.25*tickAngle;

// Sonar values
int distance = 30;
int sonar = SensorValue(ultrasonic);
int prevSonar = 255;

// Localization values
float prob = 0;

// Line following functions
task straight()
{
		motor[leftMotor] = speed + curve;
		motor[rightMotor] = speed - curve;
}
task left()
{
		motor[leftMotor] = speed - curve;
		motor[rightMotor] = speed + curve;
}
task right()
{
		motor[leftMotor] = speed + 2*curve;
		motor[rightMotor] = speed - 2*curve;
}

// Dead reckoning
float position(int leftDegrees, int rightDegrees)
{
	float leftRads = leftDegrees*PI/180;
	float leftDist = wheelR*leftRads;
	float leftAngle = leftDist/(r+wheelDist);
	leftAngle *= 180/PI;

	float rightRads = rightDegrees*PI/180;
	float rightDist = wheelR*rightRads;
	float rightAngle = rightDist/(r-wheelDist);
	rightAngle *= 180/PI;

	float angle = (leftAngle+rightAngle)/2 - fudgeFactor;
	return angle;
}

task main()
{
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	float angle = 0;
	while (prob < 0.9)
	{
		int light = SensorValue(lightSensor);
		if (light < black)
		{
			startTask(left);
		}
		else if (light > white)
		{
			startTask(right);
		}
		else
		{
			startTask(straight);
		}

		angle = position(nMotorEncoder[leftMotor], nMotorEncoder[rightMotor]);
		ticks = angle / tickAngle;
		writeDebugStreamLine("Position = %f", ticks);

		sonar = SensorValue(ultrasonic);
		if ((sonar < distance) && (prevSonar >= distance)) {
			playTone(500, 25); while(bSoundActive);
		}
		prevSonar = sonar;

		wait1Msec(waitTime);
	}
}
