#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Recall that our motors are on backwards.
// All values must be opposite.

// The robot will follow the left side of the line.

int black = 35;
int white = 55;

int turnSpeed = 20;
int straightSpeed = 40;
int curve = 10;

task straight()
{
	writeDebugStreamLine("straight");
	clearTimer(T1);
	while (time1[T1] < 10000)
	{
		motor[leftMotor] = straightSpeed + curve;
		motor[rightMotor] = straightSpeed - curve;

		int light = SensorValue(lightSensor);
		if ((light < black) || (light > white))
			break;

		//wait1Msec(1);
	}

	// Is this part necessary? It was in the sample.
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

task left()
{
	writeDebugStreamLine("left");
	clearTimer(T2);
	while (time1[T2] < 10000)
	{
		motor[leftMotor] = -turnSpeed;
		motor[rightMotor] = turnSpeed;

		int light = SensorValue(lightSensor);
		if (light > black)
			break;

		//wait1Msec(1);
	}

	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

task right()
{
	writeDebugStreamLine("right");
	clearTimer(T3);
	while (time1[T3] < 10000)
	{
		motor[leftMotor] = turnSpeed;
		motor[rightMotor] = -turnSpeed;

		int light = SensorValue(lightSensor);
		if (light < white)
			break;

		//wait1Msec(1);
	}

	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

task main()
{
	while (true)
	{
		// Adjust these as necessary:
		// Also update in the functions above

		writeDebugStreamLine("Light Value: %d", SensorValue(lightSensor));

		// Follow the left edge of the line. Light value should be ~50.
		int light = SensorValue(lightSensor);
		if (light < black)
		{
			startTask(left);
		}
		else if (light > white)
		{
			startTask(right);
		}
		else
		{
			startTask(straight);
		}

		wait1Msec(1);
	}
}
