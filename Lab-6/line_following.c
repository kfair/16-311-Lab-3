#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S2,     ultrasonic,     sensorSONAR)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Line following values
int black = 35;
int white = 55;
int waitTime = 1;
int speed = 35;
float curve = 6.5;

// Dead recknoning values
float axleLen = 4.875;
float wheelDist = axleLen / 2;
float wheelR = 1.032;			// Decrease to go farther
float r = 12;
float tickAngle = 360 / 16;
float ticks = 0;
float fudgeFactor = 0.25*tickAngle;

// Sonar values
int distance = 30;
int sonar = SensorValue(ultrasonic);
int prevSonar[4];
int prevAvg = SensorValue(ultrasonic);
int beepCounter = 0;

// Localization values
float prob = 0;

// Line following functions
task straight()
{
		motor[leftMotor] = speed + curve;
		motor[rightMotor] = speed - curve;
}
task left()
{
		motor[leftMotor] = speed - curve;
		motor[rightMotor] = speed + curve;
}
task right()
{
		motor[leftMotor] = speed + 2*curve;
		motor[rightMotor] = speed - 2*curve;
}

// Dead reckoning
float position(int leftDegrees, int rightDegrees)
{
	float leftRads = leftDegrees*PI/180;
	float leftDist = wheelR*leftRads;
	float leftAngle = leftDist/(r+wheelDist);
	leftAngle *= 180/PI;

	float rightRads = rightDegrees*PI/180;
	float rightDist = wheelR*rightRads;
	float rightAngle = rightDist/(r-wheelDist);
	rightAngle *= 180/PI;

	float angle = (leftAngle+rightAngle)/2 - fudgeFactor;
	return angle;
}

task main()
{
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	float angle = 0;
	while (prob < 0.9)
	{
		int light = SensorValue(lightSensor);
		if (light < black)
		{
			startTask(left);
		}
		else if (light > white)
		{
			startTask(right);
		}
		else
		{
			startTask(straight);
		}

		angle = position(nMotorEncoder[leftMotor], nMotorEncoder[rightMotor]);
		ticks = angle / tickAngle;
		//writeDebugStreamLine("Position = %f", ticks);


		sonar = SensorValue(ultrasonic);
		if ((sonar < distance) && (prevAvg >= distance)) {
			writeDebugStreamLine("*******************");
			writeDebugStreamLine("prevAvg = %f", prevAvg);
			writeDebugStreamLine("prevAvg = %f", prevSonar[1]);
			writeDebugStreamLine("prevAvg = %f", prevSonar[2]);
			writeDebugStreamLine("prevAvg = %f", prevSonar[3]);
			writeDebugStreamLine("Sonar = %f", sonar);
		  writeDebugStreamLine("beepCounter = %f", beepCounter);
			beepCounter += 1;
			prevSonar[1] = sonar;
			prevSonar[2] = sonar;
			prevSonar[3] = sonar;
			playTone(500, 25); while(bSoundActive);
		}


		int sum = 0;

		//update previous sonar values
		for (int i = 0; i < 3; i++){
			prevSonar[i] = prevSonar[i+1];
			sum = sum + prevSonar[i];
		}
		sum = sum + sonar;
		sum = sum - prevSonar[0];
		prevSonar[3] = sonar;

		prevAvg = sum/3;

		wait1Msec(waitTime);
	}
}
